{"meta":{"title":"Geoion","subtitle":null,"description":"404 not found","author":"Eski Yin","url":"http://eskiyin.cc"},"pages":[{"title":"about","date":"2017-06-23T19:11:37.000Z","updated":"2017-06-23T19:11:36.000Z","comments":false,"path":"about/index.html","permalink":"http://eskiyin.cc/about/index.html","excerpt":"","text":"我90后摸鱼程序员 技能相关主力开发语言: Python 这些地方找到我twitter: weibo: tumblr: wechat: v2ex:"},{"title":"categories","date":"2017-03-30T10:53:24.000Z","updated":"2017-03-13T12:56:59.000Z","comments":true,"path":"categories/index.html","permalink":"http://eskiyin.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-30T10:53:24.000Z","updated":"2017-03-13T12:57:26.000Z","comments":true,"path":"tags/index.html","permalink":"http://eskiyin.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python 中的日期和时间","slug":"python-date-and-time","date":"2017-06-23T19:10:39.000Z","updated":"2017-08-01T10:55:34.000Z","comments":true,"path":"2017/06/24/python-date-and-time/","link":"","permalink":"http://eskiyin.cc/2017/06/24/python-date-and-time/","excerpt":"最近在做数据整理的时候用到了各种时间和日期的生成操作，长期不用 datetime 和 time 模块，难免忘记很多方法的使用细节，所以干脆整理一下可能以后用到的时间生成方法，用到不要到处找。 使用的 Python 版本: 2.7.13 / 3.6.1 起步基本上所有的日期和时间的操作都是基于 datetime 和 time 模块，为Python标准库，无需安装。 Python datetime 模块：2.x / 3.xPython time 模块：2.x / 3.x","text":"最近在做数据整理的时候用到了各种时间和日期的生成操作，长期不用 datetime 和 time 模块，难免忘记很多方法的使用细节，所以干脆整理一下可能以后用到的时间生成方法，用到不要到处找。 使用的 Python 版本: 2.7.13 / 3.6.1 起步基本上所有的日期和时间的操作都是基于 datetime 和 time 模块，为Python标准库，无需安装。 Python datetime 模块：2.x / 3.xPython time 模块：2.x / 3.x 关于这两个模块： time 模块大量调用了系统的 C library 函数(Most of the functions defined in this module call platform C library functions with the same name.)，在文档中被归为 Generic Operating System Services(而 datetime 在 The Python Standard Library)，time 提供的是基于 Unix Timestamp 的操作，更接近于系统层面，而 datetime 比 time 封装了更实用的方法。 如果操作的时间范围超过 1970 - 2038 ，还是换 datetime 模块吧。 日期的格式化日常使用比较多的两种转换，是将时间对象转成字符串，另一种是将字符串转为时间对象： 使用 datetime 模块： 时间对象转成字符串: datetime.datetime.strftime() 字符串转成时间 datetime 类: datetime.datetime.strptime() 使用 time 模块： 时间对象转成字符串: time.strftime() 字符串转成 struct_time tuple: time.strptime() 日期格式化符号代表的意义： 格式 说明 取值范围 %a 缩写的星期名称 %A 完整的星期名称 %b 缩写的月份名称 %B 完整的月份名称 %c 本地化的日期和时间表示 %d 本日在当月中的第几天 01 - 31 %H 小时(24小时制) 00 - 23 %l 小时(12小时制) 01 - 12 %j 本日在当年中第几天 001 - 366 %m 本月在当年中第几个月 01 - 12 %M 分钟 00 - 59 %p 12小时制中A.M/P.M %S 秒钟 00 - 59 %U 本周在一年中的星期数(星期日为一周开始) 0 - 53 %w 本日在一周的第几天(星期日为一周开始) 0 - 6 %W 本周在一年中的星期数(星期一为一周开始) 0 - 53 %y 两位数的年份表示 00 - 99 %Y 四位数的年份表示 0000 - 9999 常用方法获取 今天的日期 和 现在的时间 使用 datetime 模块： 1234567891011121314&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.date.today()datetime.date(2017, 6, 25) &gt;&gt;&gt; datetime.date.today().strftime('%Y-%m-%d') # 用 strftime()方法将时间转化为日期字符串'2017-06-25' # 输出为 str 类型&gt;&gt;&gt; datetime.datetime.now() # today 和 now 方法都是当前时区的时间，UTC时间请使用 utcnow() 方法datetime.datetime(2017, 6, 25, 4, 35, 59, 947495)&gt;&gt;&gt; datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') # 格式化输出当前时间'2017-06-25 04:40:10'# 输出为 str 类型 使用 time 模块： 12345678910&gt;&gt;&gt; import time&gt;&gt;&gt; time.localtime() # localtime输出为本地时间，UTC 时间请使用 gmtime()方法time.struct_time(tm_year=2017, tm_mon=6, tm_mday=25, tm_hour=4, tm_min=15, tm_sec=9, tm_wday=6, tm_yday=176, tm_isdst=0)&gt;&gt;&gt; time.strftime(\"%Y-%m-%d\", time.localtime()) '2017-06-25' # 输出为 str 类型&gt;&gt;&gt; time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())'2017-06-25 04:41:19' datetime 和 time 模块都有各自的方法来获取当前的时间， 获取已知间隔的时间计算以现在为起点，明确的时间间隔的时间点，在 datetime 中提供了 timedelta 对象来计算。 获取昨天的日期： 1234&gt;&gt;&gt; datetime.datetime.today().strftime(\"%Y-%m-%d\")'2017-06-25'&gt;&gt;&gt; (datetime.datetime.today() - datetime.timedelta(days=1)).strftime(\"%Y-%m-%d\")'2017-06-24' 获取一周前的日期： 12&gt;&gt;&gt; (datetime.datetime.today() - datetime.timedelta(weeks=1)).strftime(\"%Y-%m-%d\")'2017-06-18' datetime 中 timedelta 支持的时间单位有：days、seconds、microseconds、milliseconds、minutes、hours、weeks。 获取时间点获取本周在今年是第几周： 123&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.today().strftime(\"%U\")'31' # 输出为str类型，注意转换 123&gt;&gt;&gt; import time&gt;&gt;&gt; time.strftime(\"%U\",time.localtime())'31' # 输出为str类型，注意转换 已知今年第几周，求这一周的起始和结束： 123456789&gt;&gt;&gt; import time&gt;&gt;&gt; time.strptime('2017-31-0', '%Y-%U-%w') # 一周的开始是周日time.struct_time(tm_year=2017, tm_mon=7, tm_mday=30, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=6, tm_yday=211, tm_isdst=-1)&gt;&gt;&gt; time.strftime(\"%Y-%m-%d\", time.strptime('2017-31-0', '%Y-%U-%w'))'2017-07-30'&gt;&gt;&gt; time.strptime('2017-31-6', '%Y-%U-%w') 一周的结束是周六time.struct_time(tm_year=2017, tm_mon=8, tm_mday=5, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=217, tm_isdst=-1)&gt;&gt;&gt; time.strftime(\"%Y-%m-%d\", time.strptime('2017-31-6', '%Y-%U-%w'))'2017-08-05'","categories":[{"name":"Python","slug":"Python","permalink":"http://eskiyin.cc/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://eskiyin.cc/tags/Python/"},{"name":"Datetime","slug":"Datetime","permalink":"http://eskiyin.cc/tags/Datetime/"}]},{"title":"Redis剖析","slug":"redis-dissect","date":"2017-04-02T14:30:42.000Z","updated":"2017-08-10T20:27:10.000Z","comments":true,"path":"2017/04/02/redis-dissect/","link":"","permalink":"http://eskiyin.cc/2017/04/02/redis-dissect/","excerpt":"","text":"根据同事分享的 Redis剖析 整理，算是对《Redis设计与实现》一书的理解和实际使用的总结。 redis 架构 数据结构 Redis Object目前 Redis 的数据结构有 String, List, Set, Sorted_Set, Hash 五种。 所有的对象都可以用 redisObject 结构来表示，每个对象都有 type, encoding, ptr 这三个属性。 12345typedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; void *ptr;&#125; robj; 不同的 type 对应不同的对象: type Object REDIS_STRING String REDIS_LIST List REDIS_HASH Dict REDIS_SET Hash REDIS_ZSET Zset 基于这些类型的对象，有不用的数据结构实现的编码: type encoding Object REDIS_STRING REDIS_ENCODING_INT REDIS_STRING REDIS_ENCODING_EMBSTR REDIS_STRING REDIS_ENCODING_RAW REDIS_LIST REDIS_ENCODING_ZIPLIST REDIS_LIST REDIS_ENCODING_LINKEDLIST REDIS_HASH REDIS_ENCODING_ZIPLIST REDIS_HASH REDIS_ENCODING_HT REDIS_SET REDIS_ENCODING_INTSET REDIS_SET REDIS_ENCODING_HT REDIS_ZSET REDIS_ENCODING_ZIPLIST REDIS_ZSET REDIS_ENCODING_SKIPLIST StringRedis 的 String 使用的是自己构件的 simple dynamic string(SDS) 抽象类型，基本的结构为： 12345struct sdshdr &#123; int len; //字符串长度 “Redis” =&gt; 5 int free; //buf数组中剩余的字符串长 “Redis” =&gt; 0 char buf[] //“Redis” =&gt; ['R','e','d','i','s','\\0']&#125; SDS为什么这么设计： 不同于C语言的字符串，获取字符串长度操作需要遍历整个字符串，遇到 \\0 才能返回字符串长度，SDS创建和修改操作是已经将字符串长度存在 len 中，获取超长字符串时，复杂度仅为O(1)。对于SDS的怎么工作的，详见SDS的分配策略 字符串对象的编码方式有三种：int，ram，embster。 int 字符串当保存的对象为整型的时候，数值用 long 类型表示，那么 ptr 属性将直接存储这个整型。 12345redis&gt; SET number 65535OKredis&gt; OBJECT ENCODING number&quot;int&quot; 实际上 redisObject 储存的是： 12345number = &#123; type: REDIS_STRING encoding: REDIS_ENCODING_INT ptr: 65535 // long type&#125; raw 和 embstr 字符串当保存的字符串长度大于32字节的时候将会储存为 raw 的编码方式，小于等于32字节的字符串将会被储存为 embstr 的编码方式。两种方式都是用 sdshdr 结构来存储字符串对象。 1234567891011121314151617redis&gt; SET string1 &quot;hello world! hello everbody!!!!!!!!!&quot;OKredis&gt; SET string2 &quot;hello&quot;OKredis&gt; STRLEN string1(integer) 36redis&gt; STRLEN string2(integer) 5redis&gt; ObJECT ENCODING string1&quot;raw&quot;redis&gt; ObJECT ENCODING string2&quot;embstr&quot; 除了字符串长度不同不同外，raw 和 embstr 还有一些差别，embstr 的内存是连续的，一块内存空间依次包含 redisObject 和 sdshdr， List Redis 的列表有两种编码方式： ziplist 和 linkedlist。 列表对象会根据保存的数据来选择不同的编码方式。 ziplistziplist 是用压缩列表作为底层实现，每个节点(entity)只保存一个列表元素。 当往一个 ziplist 编码的键 list1 中 RPUSH 几个元素的时候： 12redis&gt; RPUSH list1 &quot;abc&quot; 666 123(integer) 3 实际上 redisObject 储存的是： 12345list1 = &#123; type: REDIS_LIST encoding: REDIS_ENCODING_ZIPLIST ptr: [&quot;abc&quot;, 666, 123] // a zip list&#125; linkedlistlinkedlist 用双端链表作为底层实现， 每个双端链表的节点(node)都保存了一个字符串对象，每个字符串对象保存了一个列表元素。 单个节点的结构为： 12345typedef struct listNode &#123; struct listNode * prev; // 前置节点 struct listNode * next; // 后置节点 void * value; // 当前节点的值&#125;listNode; 使用多个 listNode 节点足以组成链表结构，但是为了方便使用双端链表，redis 使用了 list 结构： 12345678typedef struct list &#123; listNode * head; // 表头节点 listNode * tail; // 表尾节点 unsigned long len; // 链表所包含的节点数量 void *(*dup)(void *ptr); // 节点值复制函数 void (*free)(void *ptr); // 节点值释放函数 int (*match)(void *ptr, void *key); // 节点值对比函数&#125;list; 编码的转换 SetZsetHash单机数据库RDBAOFEventClientsserver功能PubsubTransactionBitArraySlowLogMonitor进阶LRU 淘汰策略内存分析增加命令增加新数据结构增加模块多进程 Redis","categories":[{"name":"Database","slug":"Database","permalink":"http://eskiyin.cc/categories/Database/"},{"name":"Cache","slug":"Database/Cache","permalink":"http://eskiyin.cc/categories/Database/Cache/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://eskiyin.cc/tags/Redis/"}]},{"title":"InfluxDB入门与influxdb-python","slug":"influxdb-and-influxdb-python","date":"2017-03-13T15:21:38.000Z","updated":"2017-04-07T07:47:05.000Z","comments":true,"path":"2017/03/13/influxdb-and-influxdb-python/","link":"","permalink":"http://eskiyin.cc/2017/03/13/influxdb-and-influxdb-python/","excerpt":"InfluxDBInfluxDB 是用 Go 语言编写的一个开源分布式时序、事件和指标数据库，InfluxDB 提供类 SQL 语法，很容易上手，但是又和SQL有很大差别。 InfiuxDB 同时也提供了 python client 方便开发，Github地址：influxdb-python。","text":"InfluxDBInfluxDB 是用 Go 语言编写的一个开源分布式时序、事件和指标数据库，InfluxDB 提供类 SQL 语法，很容易上手，但是又和SQL有很大差别。 InfiuxDB 同时也提供了 python client 方便开发，Github地址：influxdb-python。正好最近项目中用到了InfluxDB，梳理一些从0开始的学习过程，这里默认已经在掌握 SQL 的基本概念和操作的基础上展开。 InfluxDB 仅仅单机版本免费，集群使用并不免费，注意。 安装Mac 的开发环境下，可以使用 Homebrew 来安装 InfluxDB： 12brew updatebrew install influxdb 安装完之后可以用过 Homebrew 来来启动 InfluxDB 的服务： 1brew services start influxdb 相应的可以停止 ç 的服务： 1brew services stop influxdb 服务启动之后可以即可连接到 InfluxDB，可以说是安装成功了: 1234$ influxConnected to http://localhost:8086 version v1.2.0InfluxDB shell version: v1.2.0&gt; Influxdb-python 可以通过 pip 安装： 1pip install influxdb 与传统数据库的一些差别 influxDB SQL 含义 databse database 数据库 measurement table 数据库中的表 points row 一条记录 Point由除了数据（field）之外，还有 时间戳（time） 、标签（tags），每条数据会自动生成时间并记录，时间戳是数据库中的 主索引，标签可以作为索引的属性，将数据分类等。 基本操作InfluxDB 和 SQL 数据库的操作差别不大。 数据库操作InfluxDB 也提供了多数据库的支持，与与mysql相同： 12345&gt; show databasesname: databasesname----_internal 新建和删除数据库数据库： 12&gt; create database test&gt; drop database test 切换到使用的数据库： 1use test 表的基本操作显示所有表： 12345&gt; show measurementsname: measurementsname----students 删除表： 1&gt; drop measurement students 这里和SQL不一样的地方就是没有创建表的命令，是的你没看错，真没有，这和mongoDB类似。 数据的基本操作插入数据： 123&gt; insert [measurement],[tag],[field],[time]&gt; insert students,class=1,name=zhangsan age=20 如果之前不存在 students 这张表，这条 insert 操作相当于先执行了表的创建，此时表的字段已经确定。如果此时再往 students 表中添加新的字段，这就不行了： 12&gt; insert students,class=1,name=wangwu age=25 sex=maleERR: &#123;&quot;error&quot;:&quot;unable to parse &apos;students,class=1,name=wangwu age=25 sex=male&apos;: bad timestamp&quot;&#125; 这里报错是个 bad timestamp ，原因在于当有 n 个字段的时候，insert 后的第 n+1 个参数其实是个时间戳，可以验证一下： 1234567&gt; insert students,class=1,name=wangwu age=25 1231241231412&gt; select * from studentsname: studentstime age class name---- --- ----- ----1231241231412 25 1 wangwu1489428363333805010 20 1 zhangsan 数据查询如上所示，与 SQL 是一样的。但是 InfluxDB 属于时序数据库，所以没有提供数据修改和删除的方法。 基本用户管理查看用户： 1234&gt; show users;user admin---- -----root true 可以创建一个普通用户或者管理员权限的用户，方法和mysql类似 12&gt; create user &quot;username&quot; with password &apos;password&apos;;&gt; create user &quot;username&quot; with password &apos;password&apos; with all privileges; 像删除表和数据库一样删除用户： 1&gt; drop user ‘username’; 使用 influxdb-python导入其实到这里差不多就可以开始用 influxdb-python 了。在项目中导入模块： 1from influxdb import InfluxDBClient 连接数据库1client = InfluxDBClient('localhost', 8086, 'root', 'root', 'test') 基本用法InfluxDB 的数据库创建： 1client.create_database('test1') InfluxDB 的操作比较简单，基本大部分的操作都集中在插库和查询上： 123456789101112131415body = [ &#123; \"measurement\": \"test\", \"tags\": &#123; \"class\": 1 &#125;, \"fields\": &#123; \"name\": \"zhangsan\", \"age\": 25 &#125;, \"time\": \"2017-03-16T21:03:00Z\", &#125;]client.write_points(body) #if success return True 查询： 1result = client.query('select value from test;') 异常处理导入错误处理的 exceptions 模块： 123456from influxdb import exceptionstry: client.write_points(body)except exceptions.InfluxDBClientError as e: logging(e) InfluxDB在Python中的一些问题在Python中生成的时间戳是不满足InfluxDB的时间戳精度的， 123&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1490870040.651711 所以此处要补全一下python中的时间戳，简单粗暴的方法： 123&gt;&gt;&gt; import time&gt;&gt;&gt; int(inttime.time()*10**9)1490870857735662080 扩展阅读InfluxDB详解之TSM存储引擎解析（一）InfluxDB详解之TSM存储引擎解析（二）时间序列数据库调研之InfluxDB","categories":[{"name":"Database","slug":"Database","permalink":"http://eskiyin.cc/categories/Database/"},{"name":"Python","slug":"Database/Python","permalink":"http://eskiyin.cc/categories/Database/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://eskiyin.cc/tags/Python/"},{"name":"influxdb","slug":"influxdb","permalink":"http://eskiyin.cc/tags/influxdb/"}]}]}